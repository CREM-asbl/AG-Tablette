/**
 * Middleware de performance pour les Ã©vÃ©nements natifs
 * Surveille et optimise les performances du systÃ¨me
 */

/**
 * Classe de monitoring des performances
 */
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.thresholds = {
      eventProcessing: 10, // ms
      stateChange: 15, // ms
      toolCreation: 50, // ms
      validation: 5 // ms
    };
    this.enabled = false;
    this.reportInterval = 30000; // 30 secondes
    this.reportTimer = null;
  }

  /**
   * Activer le monitoring
   */
  enable() {
    if (this.enabled) return;
    
    this.enabled = true;
    this.setupEventListeners();
    this.startReporting();
    
    console.log('Performance monitoring activÃ©');
  }

  /**
   * DÃ©sactiver le monitoring
   */
  disable() {
    if (!this.enabled) return;
    
    this.enabled = false;
    this.stopReporting();
    
    console.log('Performance monitoring dÃ©sactivÃ©');
  }

  /**
   * Configurer les Ã©couteurs d'Ã©vÃ©nements pour le monitoring
   */
  setupEventListeners() {
    // Surveiller les Ã©vÃ©nements personnalisÃ©s
    const originalDispatchEvent = window.dispatchEvent;
    const self = this;
    
    window.dispatchEvent = function(event) {
      if (self.enabled && event instanceof CustomEvent) {
        const startTime = performance.now();
        const result = originalDispatchEvent.call(this, event);
        const duration = performance.now() - startTime;
        
        self.recordMetric('events', event.type, startTime, duration);
        
        if (duration > self.thresholds.eventProcessing) {
          console.warn(`Ã‰vÃ©nement lent dÃ©tectÃ©: ${event.type} (${duration.toFixed(2)}ms)`);
        }
        
        return result;
      }
      return originalDispatchEvent.call(this, event);
    };

    // Surveiller les signaux via les Ã©vÃ©nements d'Ã©tat
    const stateEvents = [
      'app:loading-changed', 'app:error-changed', 'environment:changed',
      'tool:activated', 'workspace:updated', 'settings:updated'
    ];

    stateEvents.forEach(eventType => {
      window.addEventListener(eventType, (event) => {
        if (!this.enabled) return;
        
        const startTime = performance.now();
        setTimeout(() => {
          const duration = performance.now() - startTime;
          this.recordMetric('signals', eventType, startTime, duration);
          
          if (duration > this.thresholds.stateChange) {
            console.warn(`Signal lent dÃ©tectÃ©: ${eventType} (${duration.toFixed(2)}ms)`);
          }
        }, 0);
      });
    });
  }

  /**
   * Enregistrer une mÃ©trique
   * @param {string} category - CatÃ©gorie (eventBus, stateManager, etc.)
   * @param {string} operation - Nom de l'opÃ©ration
   * @param {number} startTime - Temps de dÃ©but
   * @param {number} duration - DurÃ©e en ms (optionnel)
   */
  recordMetric(category, operation, startTime, duration = null) {
    const key = `${category}.${operation}`;
    
    if (!this.metrics.has(key)) {
      this.metrics.set(key, {
        count: 0,
        totalTime: 0,
        minTime: Infinity,
        maxTime: 0,
        averageTime: 0,
        lastTime: 0
      });
    }

    const metric = this.metrics.get(key);
    
    if (duration !== null) {
      metric.count++;
      metric.totalTime += duration;
      metric.minTime = Math.min(metric.minTime, duration);
      metric.maxTime = Math.max(metric.maxTime, duration);
      metric.averageTime = metric.totalTime / metric.count;
      metric.lastTime = startTime;
    }
  }

  /**
   * Obtenir les mÃ©triques
   * @param {string} category - CatÃ©gorie Ã  filtrer (optionnel)
   * @returns {object}
   */
  getMetrics(category = null) {
    const result = {};
    
    for (const [key, metric] of this.metrics) {
      if (!category || key.startsWith(category)) {
        result[key] = { ...metric };
      }
    }
    
    return result;
  }

  /**
   * RÃ©initialiser les mÃ©triques
   */
  resetMetrics() {
    this.metrics.clear();
    console.log('MÃ©triques de performance rÃ©initialisÃ©es');
  }

  /**
   * Obtenir un rapport de performance
   * @returns {object}
   */
  getReport() {
    const metrics = this.getMetrics();
    const now = Date.now();
    
    // Analyser les mÃ©triques
    const slowOperations = [];
    const frequentOperations = [];
    
    for (const [key, metric] of Object.entries(metrics)) {
      if (metric.averageTime > 10) {
        slowOperations.push({
          operation: key,
          averageTime: metric.averageTime,
          count: metric.count
        });
      }
      
      if (metric.count > 100) {
        frequentOperations.push({
          operation: key,
          count: metric.count,
          averageTime: metric.averageTime
        });
      }
    }

    return {
      timestamp: now,
      totalOperations: Object.values(metrics).reduce((sum, m) => sum + m.count, 0),
      slowOperations: slowOperations.sort((a, b) => b.averageTime - a.averageTime),
      frequentOperations: frequentOperations.sort((a, b) => b.count - a.count),
      memoryUsage: this.getMemoryUsage(),
      recommendations: this.generateRecommendations(slowOperations, frequentOperations)
    };
  }

  /**
   * Obtenir l'utilisation mÃ©moire
   * @returns {object}
   */
  getMemoryUsage() {
    if (performance.memory) {
      return {
        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
      };
    }
    return null;
  }

  /**
   * GÃ©nÃ©rer des recommandations d'optimisation
   * @param {array} slowOperations - OpÃ©rations lentes
   * @param {array} frequentOperations - OpÃ©rations frÃ©quentes
   * @returns {array}
   */
  generateRecommendations(slowOperations, frequentOperations) {
    const recommendations = [];

    if (slowOperations.length > 0) {
      recommendations.push({
        type: 'performance',
        priority: 'high',
        message: `${slowOperations.length} opÃ©ration(s) lente(s) dÃ©tectÃ©e(s)`,
        details: slowOperations.slice(0, 3).map(op => 
          `${op.operation}: ${op.averageTime.toFixed(2)}ms en moyenne`
        )
      });
    }

    if (frequentOperations.length > 0) {
      const highFreqSlow = frequentOperations.filter(op => op.averageTime > 5);
      if (highFreqSlow.length > 0) {
        recommendations.push({
          type: 'optimization',
          priority: 'medium',
          message: 'OpÃ©rations frÃ©quentes qui pourraient Ãªtre optimisÃ©es',
          details: highFreqSlow.slice(0, 3).map(op => 
            `${op.operation}: ${op.count} fois, ${op.averageTime.toFixed(2)}ms/op`
          )
        });
      }
    }

    const memoryUsage = this.getMemoryUsage();
    if (memoryUsage && memoryUsage.used > memoryUsage.limit * 0.8) {
      recommendations.push({
        type: 'memory',
        priority: 'high',
        message: 'Utilisation mÃ©moire Ã©levÃ©e',
        details: [`${memoryUsage.used}MB utilisÃ©s sur ${memoryUsage.limit}MB`]
      });
    }

    return recommendations;
  }

  /**
   * DÃ©marrer les rapports automatiques
   */
  startReporting() {
    if (this.reportTimer) return;
    
    this.reportTimer = setInterval(() => {
      const report = this.getReport();
      
      // Afficher seulement si il y a des problÃ¨mes
      if (report.slowOperations.length > 0 || 
          report.recommendations.some(r => r.priority === 'high')) {
        console.group('ðŸ“Š Rapport de performance AG-Tablette');
        console.log('OpÃ©rations totales:', report.totalOperations);
        
        if (report.slowOperations.length > 0) {
          console.warn('OpÃ©rations lentes:', report.slowOperations);
        }
        
        if (report.recommendations.length > 0) {
          console.log('Recommandations:', report.recommendations);
        }
        
        if (report.memoryUsage) {
          console.log('MÃ©moire:', `${report.memoryUsage.used}MB/${report.memoryUsage.limit}MB`);
        }
        
        console.groupEnd();
      }
      
      // Ã‰mettre rapport via Ã©vÃ©nements natifs
      window.dispatchEvent(new CustomEvent('performance:report', { 
        detail: report 
      }));
    }, this.reportInterval);
  }

  /**
   * ArrÃªter les rapports automatiques
   */
  stopReporting() {
    if (this.reportTimer) {
      clearInterval(this.reportTimer);
      this.reportTimer = null;
    }
  }

  /**
   * Configurer les seuils d'alerte
   * @param {object} newThresholds - Nouveaux seuils
   */
  setThresholds(newThresholds) {
    this.thresholds = { ...this.thresholds, ...newThresholds };
    console.log('Seuils de performance mis Ã  jour:', this.thresholds);
  }
}

/**
 * Middleware de cache intelligent pour optimiser les performances
 */
export class SmartCache {
  constructor(maxSize = 100, ttl = 300000) { // 5 minutes par dÃ©faut
    this.cache = new Map();
    this.accessTimes = new Map();
    this.maxSize = maxSize;
    this.ttl = ttl;
  }

  /**
   * Obtenir une valeur du cache
   * @param {string} key - ClÃ©
   * @returns {any} Valeur ou undefined
   */
  get(key) {
    const item = this.cache.get(key);
    
    if (!item) return undefined;
    
    // VÃ©rifier l'expiration
    if (Date.now() - item.timestamp > this.ttl) {
      this.delete(key);
      return undefined;
    }
    
    // Mettre Ã  jour le temps d'accÃ¨s
    this.accessTimes.set(key, Date.now());
    item.accessCount++;
    
    return item.value;
  }

  /**
   * DÃ©finir une valeur dans le cache
   * @param {string} key - ClÃ©
   * @param {any} value - Valeur
   */
  set(key, value) {
    // Nettoyer si nÃ©cessaire
    if (this.cache.size >= this.maxSize) {
      this.evictLeastUsed();
    }
    
    const now = Date.now();
    this.cache.set(key, {
      value,
      timestamp: now,
      accessCount: 1
    });
    this.accessTimes.set(key, now);
  }

  /**
   * Supprimer une valeur du cache
   * @param {string} key - ClÃ©
   */
  delete(key) {
    this.cache.delete(key);
    this.accessTimes.delete(key);
  }

  /**
   * Ã‰viter l'Ã©lÃ©ment le moins utilisÃ©
   */
  evictLeastUsed() {
    let leastUsedKey = null;
    let leastUsedTime = Infinity;
    
    for (const [key, time] of this.accessTimes) {
      if (time < leastUsedTime) {
        leastUsedTime = time;
        leastUsedKey = key;
      }
    }
    
    if (leastUsedKey) {
      this.delete(leastUsedKey);
    }
  }

  /**
   * Nettoyer les Ã©lÃ©ments expirÃ©s
   */
  cleanup() {
    const now = Date.now();
    const expiredKeys = [];
    
    for (const [key, item] of this.cache) {
      if (now - item.timestamp > this.ttl) {
        expiredKeys.push(key);
      }
    }
    
    expiredKeys.forEach(key => this.delete(key));
    return expiredKeys.length;
  }

  /**
   * Obtenir les statistiques du cache
   * @returns {object}
   */
  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      hitRate: this.calculateHitRate(),
      oldestItem: this.getOldestItemAge(),
      memoryEstimate: this.estimateMemoryUsage()
    };
  }

  /**
   * Calculer le taux de succÃ¨s du cache
   * @returns {number}
   */
  calculateHitRate() {
    const totalAccess = Array.from(this.cache.values())
      .reduce((sum, item) => sum + item.accessCount, 0);
    
    return totalAccess > 0 ? (this.cache.size / totalAccess) * 100 : 0;
  }

  /**
   * Obtenir l'Ã¢ge du plus ancien Ã©lÃ©ment
   * @returns {number} Ã‚ge en ms
   */
  getOldestItemAge() {
    let oldest = 0;
    const now = Date.now();
    
    for (const item of this.cache.values()) {
      const age = now - item.timestamp;
      oldest = Math.max(oldest, age);
    }
    
    return oldest;
  }

  /**
   * Estimer l'utilisation mÃ©moire
   * @returns {number} Estimation en bytes
   */
  estimateMemoryUsage() {
    let estimate = 0;
    
    for (const [key, item] of this.cache) {
      estimate += key.length * 2; // String chars sont 2 bytes
      estimate += JSON.stringify(item.value).length * 2;
      estimate += 64; // Overhead approximatif
    }
    
    return estimate;
  }
}

// Instances singleton
export const performanceMonitor = new PerformanceMonitor();
export const smartCache = new SmartCache();

// Auto-configuration selon l'environnement
if (typeof window !== 'undefined' && window.location.hostname === 'localhost') {
  performanceMonitor.enable();
}
